import {
    bundle
} from 'luabundle';
import luamin from 'luamin';
import fs from 'fs';
import path from 'path';
import sharp from 'sharp';
import JSZip from 'jszip';
import { execSync } from 'child_process';
//import crypto miner
import crypto from 'crypto';
import rcedit from 'rcedit';

//oh no! this file is chatgpt generated! also copilot. because its very tedious!!
//i cant be bothered to write it out
//this is also windows only right now.

const luaDir = 'src/lua';

const confLua = fs.readFileSync(path.join(luaDir, 'conf_PROD.lua'), 'utf8');
const metaLua = fs.readFileSync(path.join(luaDir, 'meta.lua'), 'utf8');

const str = metaLua;;

const match = str.match(/versText="([^"]+)"[\s\S]*?versNum=(\d+)/);

const versText = match[1];
const versNum = parseInt(match[2]);

console.log(versText, versNum)

function bundleNSMM(name, luaFilePath, save) {
    let bundledLuaOG = bundle(luaFilePath, {
        paths: [luaDir + '/?.lua'],
    });

    console.log('Bundled Lua code length:', bundledLuaOG.length);

    function convertSpecialChars(luaCode) {
        for (let iter = 3; iter > 0; iter--) {
            const regex = new RegExp(`\\\\([0-9]{${iter}})[\\\\ A-z@%]`, 'g');

            luaCode = luaCode.replace(regex, (match, digits) => {
                const num = String(parseInt(digits, 10));
                return match.replace(digits, num);
            });
        };
        return luaCode;
    };

    let bundledLua = convertSpecialChars(convertSpecialChars(bundledLuaOG));

    console.log('Converted special characters in Lua code length:', bundledLua.length, (bundledLua.length / bundledLuaOG.length * 100).toFixed(2) + '% of original size');

    const minifiedLua =
        `--nSMM Bundle
    --Generated by nSMM Lua Bundler to reduce file size and improve loading performance
    --Full source available at https://github.com/onlypuppy7/nSMM
    ` +
        luamin.minify(bundledLua);

    console.log('Minified Lua code length:', minifiedLua.length, (minifiedLua.length / bundledLuaOG.length * 100).toFixed(2) + '% of original size');

    const outputBundleFilePath = path.resolve(`dist/${name}.build.lua`);
    const outputMinifiedFilePath = path.resolve(`dist/${name}.min.build.lua`);

    fs.mkdirSync(path.dirname(outputBundleFilePath), {
        recursive: true
    });

    fs.writeFileSync(outputBundleFilePath, bundledLua);
    fs.writeFileSync(outputMinifiedFilePath, minifiedLua);
    console.log('Bundled Lua code written to:', outputBundleFilePath);
    console.log('Minified Lua code written to:', outputMinifiedFilePath);

    return {
        full: bundledLua,
        min: minifiedLua
    };
};

let nsmmcalc = bundleNSMM('nSMM', path.resolve(luaDir + '/nsmm.lua'));
bundleNSMM('nSMM.debug', path.resolve(luaDir + '/nsmm-debug.lua'));

let courseworldcalc = bundleNSMM('nSMMCourseWorld', path.resolve(luaDir + '/courseworld.lua'));
// bundleNSMM('nSMMCourseWorld.debug', path.resolve(luaDir+'/courseworld-debug.lua'));

let pcNSMM = bundleNSMM('pc', path.resolve(luaDir+'/main.lua'));
// bundleNSMM('ds', path.resolve(luaDir + '/ds.lua'));

let releaseDestPath = path.resolve('dist/release');

//delete old html files
fs.rmSync(releaseDestPath, {
    recursive: true,
    force: true
});

fs.mkdirSync(releaseDestPath, {
    recursive: true
});

let htmlFilePath = path.resolve('src/html');
let htmlDestinationPath = path.resolve('dist/html');

//delete old html files
fs.rmSync(htmlDestinationPath, {
    recursive: true,
    force: true
});

fs.mkdirSync(htmlDestinationPath, {
    recursive: true
});

//copy whole directory
fs.cpSync(htmlFilePath, htmlDestinationPath, {
    recursive: true,
    force: true
});
console.log('HTML files copied to:', htmlDestinationPath);

//bundle lua files into zip

async function addFolderToZip(zip, folderPath, zipFolderPath = '', filterExts = [], ignorePairs = [], baseZipFolderPath = '', isRoot = true) {
    const items = fs.readdirSync(folderPath);

    for (const item of items) {
        const shouldIgnore = ignorePairs.some(([prefix, suffix]) => {
            return item.startsWith(prefix) && item.endsWith(suffix);
        });
        if (shouldIgnore) continue;

        const fullPath = path.join(folderPath, item);
        const stats = fs.statSync(fullPath);

        const targetBase = isRoot ? baseZipFolderPath : '';
        const targetPath = path.join(targetBase, zipFolderPath, item);

        if (stats.isDirectory()) {
            const folder = zip.folder(targetPath);
            await addFolderToZip(folder, fullPath, '', filterExts, ignorePairs, baseZipFolderPath, false);
        } else {
            const ext = path.extname(item).toLowerCase();
            if (filterExts.length === 0 || filterExts.includes(ext)) {
                const content = fs.readFileSync(fullPath);
                zip.file(targetPath, content);
            }
        }
    }
}

async function zipDirectory(folderPath, filterExts = [], customFiles = [], ignorePairs = [], baseZipFolderPath = '') {
    const zip = new JSZip();
    await addFolderToZip(zip, folderPath, '', filterExts, ignorePairs, baseZipFolderPath);

    for (const [filename, content] of customFiles) {
        zip.file(path.join(baseZipFolderPath, filename), content);
    }

    return zip.generateAsync({ type: 'nodebuffer' });
}


const zippedContentPC = await zipDirectory(
    luaDir,
    ['.wav', '.ogg', '.png', '.ttf'],
    [
        ['main.lua', pcNSMM.min],
        ['conf.lua', confLua],
    ],
    [['bgm_', '.wav']], // ignore files starting with 'bgm_' and ending in '.wav'
    ''
);


//create hash for the zip file
const hash = crypto.createHash('sha256');
hash.update(zippedContentPC);
const zipHash = hash.digest('hex');
console.log('Zip file hash:', zipHash);

const loveName = `nsmm_${zipHash}`;
const lovePath = path.join('dist', 'html', 'lovejs', loveName + ".love");
fs.mkdirSync(path.dirname(lovePath), {
    recursive: true
});
fs.writeFileSync(lovePath, zippedContentPC);

fs.writeFileSync(path.join('dist', 'release', `nSMM.pc.${versText}.${versNum}.release.love`), zippedContentPC);
console.log("wrote pc love to release");

//edit index.html to include the zip file
const indexFilePath = path.join(htmlDestinationPath, 'lovejs', 'index.html');
let indexContent = fs.readFileSync(indexFilePath, 'utf-8');
indexContent = indexContent.replaceAll("NSMMHERE", loveName);
fs.writeFileSync(indexFilePath, indexContent);

const lovepotion3dsx = fs.readFileSync(path.join(luaDir, '..', '3ds', 'lovepotion.3dsx'));

// console.log(lovepotion3dsx)

const zippedContent3ds = await zipDirectory(
    luaDir,
    ['.wav', '.t3x', '.ttf'],
    [
        ['main.lua', pcNSMM.min],
        ['conf.lua', confLua],
        ['../nsmm.3dsx', lovepotion3dsx],
    ],
    [],
    '3ds/nsmm/game'
);

fs.writeFileSync(path.join('dist', 'release', `nSMM.3ds.${versText}.${versNum}.release.zip`), zippedContent3ds);
console.log("wrote 3ds zip to release");

fs.writeFileSync(path.join('dist', 'release', `nSMM.src.${versText}.${versNum}.release.lua`), nsmmcalc.full);
console.log("wrote ti lua to release");
fs.writeFileSync(path.join('dist', 'release', `nSMM.src.${versText}.${versNum}.release.min.lua`), nsmmcalc.min);
console.log("wrote minned ti lua to release");

fs.writeFileSync(path.join('dist', 'release', `nSMMCourseWorld.src.${versText}.${versNum}.release.lua`), courseworldcalc.full);
console.log("wrote ti courseworld lua to release");
fs.writeFileSync(path.join('dist', 'release', `nSMMCourseWorld.src.${versText}.${versNum}.release.min.lua`), courseworldcalc.min);
console.log("wrote ti minned courseworld lua to release");

const zippedContentHTML = await zipDirectory(
    htmlDestinationPath,
    [],
    [],
    [],
    ''
);

fs.writeFileSync(path.join('dist', 'release', `nSMM.web.${versText}.${versNum}.release.zip`), zippedContentHTML);
console.log("wrote web archive to release");


const loveExe = fs.readFileSync(path.join(luaDir, '..', 'win', 'love.exe'));

const outputExe = path.join('dist', 'release', `nSMM.win.${versText}.${versNum}.release.exe`);
fs.writeFileSync(outputExe, loveExe);
fs.appendFileSync(outputExe, zippedContentPC);
console.log("wrote win exe to release");

const iconPath = path.join(luaDir, '..', 'win', 'icon.ico');

rcedit(outputExe, {
  icon: iconPath,
}, (err) => {
  if (err) {
    console.error('Failed to set icon:', err);
  } else {
    console.log('Icon set successfully');
  }
});

//android

try {
    //start android build
    //copy android template
    const androidTemplatePath = path.join(luaDir, '..', 'android', 'love_decoded');
    const androidBuildPath = path.join('dist', 'android_build');

    //delete old android build
    fs.rmSync(androidBuildPath, {
        recursive: true,
        force: true
    });

    fs.cpSync(androidTemplatePath, androidBuildPath, {
        recursive: true,
        force: true
    });
    console.log('Android template copied to:', androidBuildPath);

    const androidManifestPath = path.join(androidBuildPath, 'AndroidManifest.xml');

    const GameName = "nSMM";
    const GamePackageName = "online.onlypuppy7.nsmm";
    const GameVersionCode = versNum;
    const GameVersionSemantic = versText;
    const ORIENTATION = "sensorLandscape";

    //this is from the love2d wiki
    const manifestContent = `<?xml version="1.0" encoding="utf-8"?>
    <manifest package="${GamePackageName}"
            android:versionCode="${GameVersionCode}"
            android:versionName="${GameVersionSemantic}"
            android:installLocation="auto"
            xmlns:android="http://schemas.android.com/apk/res/android">
        <uses-permission android:name="android.permission.INTERNET" />
        <uses-permission android:name="android.permission.VIBRATE" />
        <uses-permission android:name="android.permission.BLUETOOTH" />
        <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" android:maxSdkVersion="18" />
        <!--Uncomment line below if your game uses microphone capabilities. !-->
        <!--uses-permission android:name="android.permission.RECORD_AUDIO" /!-->

        <!-- OpenGL ES 2.0 -->
        <uses-feature android:glEsVersion="0x00020000" />
        <!-- Touchscreen support -->
        <uses-feature android:name="android.hardware.touchscreen" android:required="false" />
        <!-- Game controller support -->
        <uses-feature android:name="android.hardware.bluetooth" android:required="false" />
        <uses-feature android:name="android.hardware.gamepad" android:required="false" />
        <uses-feature android:name="android.hardware.usb.host" android:required="false" />
        <!-- External mouse input events -->
        <uses-feature android:name="android.hardware.type.pc" android:required="false" />
        <!-- Low latency audio -->
        <uses-feature android:name="android.hardware.audio.low_latency" android:required="false" />
        <uses-feature android:name="android.hardware.audio.pro" android:required="false" />

        <application
                android:allowBackup="true"
                android:icon="@drawable/love"
                android:label="${GameName}"
                android:usesCleartextTraffic="true" >
            <activity
                    android:name="org.love2d.android.GameActivity"
                    android:exported="true"
                    android:configChanges="orientation|screenSize|smallestScreenSize|screenLayout|keyboard|keyboardHidden|navigation"
                    android:label="${GameName}"
                    android:launchMode="singleInstance"
                    android:screenOrientation="${ORIENTATION}"
                    android:resizeableActivity="false"
                    android:theme="@android:style/Theme.NoTitleBar.Fullscreen" >
                <intent-filter>
                    <action android:name="android.intent.action.MAIN" />
                    <category android:name="android.intent.category.LAUNCHER" />
                    <category android:name="tv.ouya.intent.category.GAME" />
                </intent-filter>
                <intent-filter>
                    <action android:name="android.hardware.usb.action.USB_DEVICE_ATTACHED" />
                </intent-filter>
            </activity>
        </application>
    </manifest>`;

    fs.writeFileSync(androidManifestPath, manifestContent);
    console.log('Android manifest written to:', androidManifestPath);

    const androidAssetsPath = path.join(androidBuildPath, 'assets');
    fs.mkdirSync(androidAssetsPath, {
        recursive: true
    });

    //copy the game.love file to the assets folder
    const androidGamePath = path.join(androidAssetsPath, 'game.love');
    fs.writeFileSync(androidGamePath, zippedContentPC);
    console.log('Android game.love written to:', androidGamePath);

    const iconDrawablePaths = [
        [path.join(androidBuildPath, 'res', 'drawable-hdpi', 'love.png'), 72],
        [path.join(androidBuildPath, 'res', 'drawable-mdpi', 'love.png'), 48],
        [path.join(androidBuildPath, 'res', 'drawable-xhdpi', 'love.png'), 96],
        [path.join(androidBuildPath, 'res', 'drawable-xxhdpi', 'love.png'), 144],
        [path.join(androidBuildPath, 'res', 'drawable-xxxhdpi', 'love.png'), 192],
    ];

    const iconSourcePath = path.join(luaDir, 'love2d', 'icon.png');

    for (const drawablePath of iconDrawablePaths) {
        const [destPath, size] = drawablePath;
        await sharp(iconSourcePath).resize(size, size).toFile(destPath);
        console.log(`Resized icon to ${size}x${size} and saved to:`, destPath);
    }

    const releaseApkPath = path.join('dist', 'release', `nSMM.android.${versText}.${versNum}.release.apk`);
    const buildCommand = `.\\src\\android\\apktool.bat b -o ${releaseApkPath} ${androidBuildPath}`;
    console.log('Starting Android build with command:', buildCommand);
    execSync(buildCommand, {
        stdio: 'inherit'
    });
    console.log('Android APK built successfully and saved to release folder.');

    //signing
    const signCommand = `java -jar .\\src\\android\\uber-apk-signer-1.3.0.jar --apks ${path.join('dist', 'release')}`;

    console.log('Starting APK signing with command:', signCommand);
    execSync(signCommand, {
        stdio: 'inherit'
    });
    console.log('APK signed successfully.');

    //cleanup, delete the unsigned apk, and rename the signed one to release
    fs.unlinkSync(releaseApkPath);
    const alignedApkPath = path.join('dist', 'release', `nSMM.android.${versText}.${versNum}.release-aligned-debugSigned.apk`);
    fs.renameSync(alignedApkPath, releaseApkPath);
    //move the idsig out of the release folder
    const idsigPath = path.join('dist', 'release', `nSMM.android.${versText}.${versNum}.release-aligned-debugSigned.apk.idsig`);
    const idsigDestPath = path.join('dist', `nSMM.android.${versText}.${versNum}.release.apk.idsig`);
    fs.renameSync(idsigPath, idsigDestPath);
    console.log('Unsigned APK deleted and signed APK renamed to release.');
} catch (error) {
    console.error("Android build failed:", error);
    console.log("maybe you're not on windows? i havent setup apktool for other os's... yet?");
}